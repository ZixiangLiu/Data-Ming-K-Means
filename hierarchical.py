#!/usr/bin/env
# Python 3.6.0
# Zixiang Liu
'''
this code implements hierarchical clustering in the simplest way. 
the input comes from get_words.py
the outputs are three txt files:
    hierarchical_time.txt:
        this file records the time used by each of three methods
    hierarchical_output.txt:
        this file records the output of intuitive method of hierarchical clustering
    dyn_hierarchical_output.txt:
        this file records the output of the optimized(dynamic) hierarchical 
        clustering
    both methods have the same output, but dynamic method used the least time. 

the main part is at the end of the code
'''

#----------------------------------------------------------------------------------#

import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import numpy as np
import random
import sys
import time

#----------------------------------------------------------------------------------#
'''
this block of code reads the words form a txt file generated by get_words.py
'''
def get_file_words(filename, cal_range = False, wordstart = 0, wordend = 100):
    '''
    get words into list from file
    two lists will be generated, wordlist which is the string which records the 
    words in bloglist, and bloglist which records the frequency of each word in each
    blog

    Args:
        filename (string): name of the file from which we get words
        cal_range (boolean): True to get words from a start and an end, False to 
                                get all words
        wordstart (int): the index of word where we start reading
        wordend (int): the index of word where we end reading
    Return:
        wordlist (list of string): the words
        bloglist (list of list of float): the frequency of words in each blog
    '''
    inputfile = open(filename, "r")
    wordlist = []
    bloglist = []
    with inputfile as filestream:
        first = True
        for line in filestream:
            linelist = line.split();
            if first:
                for word in linelist:
                    wordlist.append(word)
                first = False
            else:
                blog = []
                if cal_range:
                    for count in linelist[wordstart:wordend]:
                        blog.append(float(count))
                else:
                    for count in linelist:
                        blog.append(float(count))
                bloglist.append(blog)
    return wordlist, bloglist

#----------------------------------------------------------------------------------#
'''
this block of codes defines the methods used to calculate distance(euclidean is 
recommended), and TF-IDF method the normalize the word list
'''

def euclidean(blog1, blog2):
    '''
    calculate the distance between two blogs

    Args:
        blog1 (list of floats): each float represents the frequency of that word 
                                    in the blog
        blog2 (list of floats): same as blog 1, but a different blog, 
                                    has to be same length as blog1
    Return: 
        distance (float): sum of square of difference of each float
    '''
    if len(blog1) != len(blog2):
        return None;
    distance = 0
    for i in range(0, len(blog1)):
        distance += (blog1[i] - blog2[i])**2
    return distance

def blog_tanimoto(blog1, blog2):
    '''
    calculate the tanimoto or Jaccard distance between two blogs

    Args:
        blog1 (list of floats): each float represents the frequency 
                                of that word in the blog
        blog2 (list of floats): same as blog 1, but a different blog, 
                                has to be same length as blog1
    Return: 
        distance (float): sum of square of difference of each float
    '''
    if len(blog1) != len(blog2):
        return None;
    different_item = 0
    for i in range(0, len(blog1)):
        if blog1[i] != blog2[i]:
            different_item+= 1
    return different_item/len(blog1)

def tf(somelist):
    '''
    Term frequency:
    augmented frequency

    Args:
        somelist (list of floats): one list of floats, one blog in this program
    Return: 
        somelist (list of floats): normalized list
    '''
    for onelist in somelist:
        maxf = max(onelist)
        if maxf != 0:
            for i in range(0, len(onelist)):
                onelist[i] = 0.5 + 0.5 * onelist[i] / maxf
        else:
            break;
    return somelist


def tfidfs(somelist):
    '''
    tfâ€“idf
    tf * idf
    Inverse document frequency:
    inverse document frequency smooth
    use tfidfs(tf(somelist)) to work

    Args:   
        somelist (list of floats): one list of floats, one blog in this program
    Return: 
        somelist (list of floats): normalized list using both tf & idf
    '''
    N = len(somelist)
    somelist = np.array(somelist)
    for i in range(0, len(somelist[0])):
        # start with 1 to make it smooth and none zero
        nt = 1
        for j in range(0, N):
            if somelist[:,i][j] != 0.5:
                nt += 1
        idfs = np.log(N/nt)
        for j in range(0, N):
            somelist[:,i][j] += idfs
    return somelist


def normalizer(totallist, debugging = False):
    '''
    normalize data
    (i-u)/std

    Args:   
        totallist (list of list of floats): list of smaller lists, each smaller 
                                            list is a blog, containning numbers as 
                                            frequencies
        debugging (boolean): default False, set true to print info while running
    Return: 
        totallist (list of list of floats): nomalized totallist using both 
                                            tf and idf
    '''
    totallength = len(totallist[0])
    if debugging:
        print("start normaling")
    for i in range(0, totallength):
        if debugging:
            print("normalizing column No.{}".format(i))
        listavg = sum(np.array(totallist)[:,i])/float(totallength)
        liststd = np.std(np.array(totallist)[:,i], dtype=np.float64)
        for k in range(0, len(totallist)):
            totallist[k][i] = (totallist[k][i]-listavg)/liststd
    return totallist


def distsumer(pivots, inputlist, clusters):
    '''
    Sum of distance to pivot centers

    Args:
        pivots (list of list of floats): centers of the K-means algorithm
        inputlist (list of list of floats): list of smaller lists, each smaller 
                                            list is a blog, containning numbers 
                                            as frequencies
        group (dictionary): key is pivots index, value is list of inputlist 
                            indexes in that cluster
    Return: 
        sumofdist (float): summation of sum of distances in each group
    '''
    sumofdist = 0
    for key, value in clusters.items():
        for index in value:
            sumofdist += blog_dist(pivots[key], inputlist[index])
    return sumofdist

#----------------------------------------------------------------------------------#
'''
intuitive method

this method used the most intuitive method to implement hierarchical clustering 
It is extremely redundant but the code is easy to generate

the idea is to treat each blog as a list with one element. Find the most close other 
group and merge them. repeat the process untill only two groups left. 
'''

def group_blog(blog1, blog2, dist, gdtype):
    '''
    calculate the distance between two list of blogs
    there are three methods:
        single linkage: the closest distance between two points of two blogs 
                        determines the group distance
        complete linkage: the furthest points of two blogs determines
        average linkage: the best method, average distane between each of two 
                            points in two blogs
    
    Args:
        blog1 (list of list of floats): the list of blogs, each blog is a list
                                        floats indicating the frequencies of words
                                        in blogs
        blog2 (list of list of floats): same as blog1 but a different list
        dist (function with args(list of floats, list of floats)): the most basic 
                                                        function used to calculate
                                                        distance between two blogs
        gdtype (int): 0 for min distance between(simple linkage), 
                        1 for max distance between(complete linkage), 
                        2 for average(average linkage)
    Returns:
        groupdist (float): the distance between two group of blogs
    '''
    distmap = []
    for i in range(len(blog1)):
        ilist = []
        for j in range(len(blog2)):
            ilist.append(dist(blog1[i], blog2[j]))
        distmap.append(ilist)
    groupdist = 0
    if gdtype == 0:
        groupdist = sys.maxsize
        for i in range(len(blog1)):
            for j in range(len(blog2)):
                if groupdist > distmap[i][j]:
                    groupdist = dismap[i][j]
    elif gdtype == 1:
        groupdist = 0
        for i in range(len(blog1)):
            for j in range(len(blog2)):
                if groupdist < distmap[i][j]:
                    groupdist = distmap[i][j]
    else:
        groupdist = sum([sum(x) for x in distmap])/(len(blog1)*len(blog2))
    return groupdist

def find_min(inputlist, blog_dist, grouplist, gdtype):
    '''
    find the two blogs with minimum distance, and merge them

    Args:
        inputlist (list of list of list of floats): list of smaller lists, 
                            each smaller list is a list of blogs, each blog 
                            contains floats as frequencies of words in that blog
        blog_dist (function with args(list of floats, list of floats)): function 
                            to calculate distance between two blogs
        grouplist (list of list of ints): list of cluster situation of the index
                            of blogs in inputlist. length of grouplist indicates
                            the number of clusters exists currently. The length 
                            of each element in grouplist indicates the elements 
                            in that cluster, in the form of indexes of that blog
                            in inputlist
        gdtype (int): type of distance method used in calculating group distances
    Return:
        inputlist (list of list of floats): list of smaller lists, 
                            each smaller list is a list of blogs, each blog 
                            contains floats as frequencies of words in that blog.
                            Now the output is one cluster less thaninput one
        mini (int): index of one of the two blogs that are closest to each other
        minj (int): index of the other blog that are closest to mini
        grouplist (list of list of ints): list of cluster situation of the index
                            of blogs in inputlist. length of grouplist indicates
                            the number of clusters exists currently. The length 
                            of each element in grouplist indicates the elements 
                            in that cluster, in the form of indexes of that blog
                            in inputlist. Now the output is one cluster less than
                            input one
    '''
    dismap = []
    length = len(inputlist)
    for i in range(0, length):
        ilist = []
        for j in range(0, length):
            ilist.append(group_blog(inputlist[i], inputlist[j], blog_dist, gdtype))
        dismap.append(ilist)
    mindist = sys.maxsize
    mini = 0
    minj = 0
    for i in range(length):
        for j in range(length):
            if i != j and dismap[i][j] < mindist:
                mindist = dismap[i][j]
                mini = i
                minj = j
    inputlist[mini].extend(inputlist[minj])
    grouplist[mini].extend(grouplist[minj])
    inputlist.pop(minj)
    grouplist.pop(minj)
    return inputlist, mini, minj, grouplist

def hierarchical(inputlist, blog_dist, group_dist = "average"):
    '''
    run hierarchical clustering and output a dictionary with key as the number of 
                            clusters, and value as the grouplist at number of 
                            clusters
    
    Args:
        inputlist (list of list of floats): list of smaller lists, each smaller 
                                list is a blog, containning numbers as frequencies
        blog_dist (function with args(list of floats, list of floats)): function 
                            to calculate distance between two blogs
        group_dist (String): default average linkage which is hte better. 
                            "single" chooses single linkage, 
                            "complete" chooses complete linkage
                            all other inputs chooses average linkage
    Return:
        inputlist (list of list of floats): list of smaller lists, 
                            each smaller list is a list of blogs, each blog 
                            contains floats as frequencies of words in that blog.
                            Now the output is one cluster less thaninput one
        groupdict (dictionary of grouplists): key is the number of clusters
                            value is the grouplist
        time (float): time used to do all calculation
    '''

    group_dist_type = 2
    if group_dist == "single":
        group_dist_type = 0
    elif group_dist == "complete":
        group_dist_type = 1

    inputlist = [[x] for x in inputlist]
    grouplist = [[x] for x in range(len(inputlist))]
    groupdict = {}
    start = time.time()
    while(len(inputlist)>2):
        inputlist, i, j, grouplist = find_min(inputlist, blog_dist, grouplist, 
            group_dist_type)
        groupdict[len(inputlist)] = [x[:] for x in grouplist]
    return inputlist, groupdict, time.time()-start

#----------------------------------------------------------------------------------#
'''
a dynamic method, uses np array to store distance between blogs in order to avoid 
repeated calculation
'''

def dist_matrix(inputlist, blog_dist):
    '''
    calculate the distance in the form of a 2D numpy array, in the following form
    shape length of inputlist * length of inputlist
    blog No |  1   |   2  | ...
    --------+------+------+------
       1    |
    --------+
       2    |  
    --------+
      ...   |
    so calculation after this can be substituded by consulting this matrix

    Args:
        inputlist (list of list of floats): list of smaller lists, each smaller 
                                list is a blog, containning numbers as frequencies
        blog_dist (function with args(list of floats, list of floats)): function 
                            to calculate distance between two blogs
    Return:
        dmatrx (2d np array): distance matrix
    '''
    length = len(inputlist)
    dmatrx = np.zeros((length, length))
    for i in range(length-1):
        for j in range(i+1, length):
            dmatrx[i][j] = blog_dist(inputlist[i], inputlist[j])
            dmatrx[j][i] = dmatrx[i][j]
    return dmatrx

def dyn_group_dist(dmatrx, i, j, grouplist, gdtype):
    '''
    calculate the distance between two list of blogs
    there are three methods:
        single linkage: the closest distance between two points of two blogs 
                        determines the group distance
        complete linkage: the furthest points of two blogs determines
        average linkage: the best method, average distane between each of two 
                            points in two blogs
    every similar to the previous one, but using a more dynamic method
    
    Args:
        dmatrx (2d np array): distance matrix
        i (int): the index of a group of indexes in grouplist, each index 
                            represents a blog, each blog is a list
                            floats indicating the frequencies of words in blog
        j (int): the same as i but a different group
        blog2 (list of list of floats): same as blog1 but a different list
        dist (function with args(list of floats, list of floats)): the most basic 
                                                        function used to calculate
                                                        distance between two blogs
        gdtype (int): 0 for min distance between(simple linkage), 
                        1 for max distance between(complete linkage), 
                        2 for average(average linkage)
    Returns:
        groupdist (float): the distance between two group of blogs
    '''
    if gdtype == 2:
        distsum = 0.
        for k in grouplist[i]:
            for l in grouplist[j]:
                distsum += dmatrx[k][l]
        return distsum/(len(grouplist[i])*len(grouplist[j]))
    if gdtype == 0:
        groupdist = sys.maxsize
        for k in grouplist[i]:
            for l in grouplist[j]:
                if dmatrx[k][l] < groupdist:
                    groupdist = dmatrx[l][k]
        return groupdist
    if gdtype == 1:
        groupdist = 0
        for k in grouplist[i]:
            for l in grouplist[j]:
                if dmatrx[k][l] > groupdist:
                    groupdist = dmatrx[l][k]
        return groupdist

def dyn_find_min(dmatrx, grouplist, gdtype):
    '''
    find the two blogs with minimum distance, and merge them
    dynamic method, only deal with the index

    Args:
        dmatrx (2d np array): distance matrix
        grouplist (list of list of ints): list of cluster situation of the index
                            of blogs in inputlist. length of grouplist indicates
                            the number of clusters exists currently. The length 
                            of each element in grouplist indicates the elements 
                            in that cluster, in the form of indexes of that blog
                            in inputlist
        gdtype (int): type of distance method used in calculating group distances
    Return:
        mini (int): index of one of the two blogs that are closest to each other
        minj (int): index of the other blog that are closest to mini
        grouplist (list of list of ints): list of cluster situation of the index
                            of blogs in inputlist. length of grouplist indicates
                            the number of clusters exists currently. The length 
                            of each element in grouplist indicates the elements 
                            in that cluster, in the form of indexes of that blog
                            in inputlist. Now the output is one cluster less than
                            input one
    '''
    glength = len(grouplist)
    mindist = sys.maxsize
    mini = 0
    minj = 0
    for i in range(glength-1):
        for j in range(i+1, glength):
            tempdist = dyn_group_dist(dmatrx, i, j, grouplist, gdtype)
            if tempdist < mindist:
                mindist = tempdist
                mini = i
                minj = j
    grouplist[mini].extend(grouplist[minj])
    grouplist.pop(minj)
    return mini, minj, grouplist

def dyn_hierarchical(inputlist, blog_dist, group_dist = "average"):
    '''
    run hierarchical clustering and output a dictionary with key as the number of 
    clusters, and value as the grouplist at number of clusters
    dynamic method only calculate distance once and then use index to represent 
    each blog
    
    Args:
        inputlist (list of list of floats): list of smaller lists, each smaller 
                                list is a blog, containning numbers as frequencies
        blog_dist (function with args(list of floats, list of floats)): function 
                            to calculate distance between two blogs
        group_dist (String): default average linkage which is hte better. 
                            "single" chooses single linkage, 
                            "complete" chooses complete linkage
                            all other inputs chooses average linkage
    Return:
        inputlist (list of list of floats): list of smaller lists, 
                            each smaller list is a list of blogs, each blog 
                            contains floats as frequencies of words in that blog.
                            Now the output is one cluster less thaninput one
        groupdict (dictionary of grouplists): key is the number of clusters
                            value is the grouplist
        time (float): time used to do all calculation
    '''
    grouplist = [[x] for x in range(len(inputlist))]

    group_dist_type = 2
    if group_dist == "single":
        group_dist_type = 0
    elif group_dist == "complete":
        group_dist_type = 1

    groupdict = {}
    start = time.time()
    dmatrx = dist_matrix(inputlist, blog_dist)
    while(len(grouplist)>2):
        i, j, grouplist = dyn_find_min(dmatrx, grouplist, group_dist_type)
        groupdict[len(grouplist)] = [x[:] for x in grouplist]
    time_total = time.time()-start
    return groupdict, time_total

#----------------------------------------------------------------------------------#
'''
this block of code print the output to standard output or write to file
'''

def print_groupdict(groupdict):
    '''
    print a groupdict to standard output

    Args:
        groupdict (dictionary of grouplists): key is the number of clusters
                            value is the grouplist
    '''
    for key, value in groupdict.items():
        print("\n{} clusters:".format(key))
        for i in range(key):
            print("{}: {}".format(i, value[i]))
        print()

def write_groupdict(filename, groupdict):
    '''
    write the groupdict to file

    Args:
        filename (string): name of the file 
        groupdict (dictionary of grouplists): key is the number of clusters
                            value is the grouplist
    '''
    file = open(filename, "w")
    for key, value in groupdict.items():
        file.write("{} clusters:\n".format(key))
        for i in range(key):
            file.write("{}: {}\n".format(i, value[i]))
        file.write("\n\n")
    file.close()

#----------------------------------------------------------------------------------#
'''
main method
'''

timefile = open("hierarchical_time.txt", "a")

for i in range(10):
    # get the words from txt file
    wordlist, bloglist =  get_file_words("output.txt")
    bloglist = tfidfs(tf(bloglist))

    # run intuitive method
    bloglist, groupdict, htime = hierarchical(bloglist, euclidean)
    write_groupdict("hierarchical_output.txt", groupdict)

    # get the words from txt file again since intuitive method changes bloglist
    wordlist, bloglist =  get_file_words("output.txt")
    bloglist = tfidfs(tf(bloglist))

    # run the dynamic method
    dyn_groupdict, dtime = dyn_hierarchical(bloglist, euclidean)
    write_groupdict("dyn_hierarchical_output.txt", dyn_groupdict)

    # write the time used by both methods to file
    timefile.write("{:12.6f} {:12.6f}\n".format(htime, dtime))
    print("Run No.{} is complete.".format(i+1))
timefile.close()





















